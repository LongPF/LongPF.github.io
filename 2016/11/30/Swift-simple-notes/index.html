<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="null">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Swift基础简单笔记 - 龙鹏飞的博客 | longpengfei&#39;s Blog
        
    </title>

    <link rel="canonical" href="longpengfei.com/2016/11/30/Swift-simple-notes/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">longpengfei&#39;s blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="longpengfei.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Swift" title="Swift">Swift</a>
                        
                    </div>
                    <h1>Swift基础简单笔记</h1>
                    <h2 class="subheading">笔记,更新下加个目录</h2>
                    <span class="meta">
                        Posted by longpengfei on
                        2016-11-30
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>#Swift基础简单笔记</p>
<p><a href="http://www.runoob.com/swift/swift-tutorial.html" target="_blank" rel="external">全文地址</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><ol>
<li><a href="#渣渣">渣渣</a></li>
</ol>
</li>
<li><ol>
<li><a href="#函数">函数</a></li>
</ol>
</li>
<li><ol>
<li><a href="#闭包">闭包</a></li>
</ol>
</li>
<li><ol>
<li><a href="#枚举">枚举</a></li>
</ol>
</li>
<li><ol>
<li><a href="#结构体">结构体</a></li>
</ol>
</li>
<li><ol>
<li><a href="#类">类</a></li>
</ol>
</li>
<li><ol>
<li><a href="#属性">属性</a></li>
</ol>
</li>
<li><ol>
<li><a href="#方法">方法</a></li>
</ol>
</li>
<li><ol>
<li><a href="#下标脚本">下标脚本</a></li>
</ol>
</li>
<li><ol>
<li><a href="#继承">继承</a></li>
</ol>
</li>
<li><ol>
<li><a href="#构造,析构,可选链">构造,析构,可选链</a></li>
</ol>
</li>
<li><ol>
<li><a href="#自动引用计数">自动引用计数</a></li>
</ol>
</li>
<li><ol>
<li><a href="#类型转换">类型转换</a></li>
</ol>
</li>
<li><ol>
<li><a href="#扩展">扩展</a></li>
</ol>
</li>
<li><ol>
<li><a href="#协议">协议</a></li>
</ol>
</li>
<li><ol>
<li><a href="#泛型">泛型</a></li>
</ol>
</li>
<li><ol>
<li><a href="#访问控制">访问控制</a></li>
</ol>
</li>
</ul>
<p><span id="渣渣"></span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var aa:Float</div><div class="line">aa = 3.14</div><div class="line">print(aa)</div></pre></td></tr></table></figure>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;666&quot;</div><div class="line">var site = &quot;777&quot;</div><div class="line">print(&quot;\(name)dddd\(site)&quot;)</div></pre></td></tr></table></figure>
<p><strong>16进制小数 :</strong><br>0xFp2 表示 15 ⨉ 2^2，也就是 60；同样，0xFp-2 表示 15 ⨉ 2^-2，也就是 3.75</p>
<h1 id="区间运算"><a href="#区间运算" class="headerlink" title="区间运算"></a>区间运算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for index in 1...5 &#123;</div><div class="line">    print(index)</div><div class="line">&#125;</div><div class="line"></div><div class="line">for index in 1..&lt;5 &#123;</div><div class="line">    print(&quot;\(index)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://www.runoob.com/swift/swift-fallthrough-statement.html" target="_blank" rel="external">fallthrough 贯穿case</a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//使用字符串字面量</div><div class="line">var stringA = &quot;Hello,World!&quot;</div><div class="line">//String实例化</div><div class="line">var stringB = String(&quot;Hello,World!&quot;)</div><div class="line">//拼接</div><div class="line">var str = &quot;123&quot;</div><div class="line">str += &quot;890&quot;</div><div class="line">//插入</div><div class="line">var stringA = &quot;\(varA) 乘于 \(constA) 等于 \(varC * 100)&quot;</div><div class="line">//比较</div><div class="line">varA == varB</div><div class="line">varA &lt; varB</div><div class="line">//empty</div><div class="line">str.isEmpty</div><div class="line">//是否有前缀...</div><div class="line">hasPrefix</div><div class="line">//转化为int</div><div class="line">Int(String)</div><div class="line">//长度</div><div class="line">String.characters.count</div><div class="line">//utf8</div><div class="line">utf8</div></pre></td></tr></table></figure>
<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//创建 </div><div class="line">let char1: Character = &quot;A&quot; //不能创建空字符 &quot;&quot;</div><div class="line"></div><div class="line">//遍历</div><div class="line">for ch in &quot;Runoob&quot;.characters &#123;</div><div class="line">    print(ch)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//拼接</div><div class="line">var varA:String = &quot;Hello &quot;</div><div class="line">let varB:Character = &quot;G&quot;</div><div class="line">varA.append( varB )</div></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var someInts = [Int](repeatElement(0, count: 3))</div><div class="line">someInts[1] = 1</div><div class="line">someInts.append(6)</div><div class="line">someInts += [40,8]</div><div class="line">someInts.insert(99, at: 0)</div><div class="line">someInts.count</div><div class="line">someInts.isEmpty</div><div class="line">arr1 + arr2</div><div class="line"></div><div class="line">//遍历</div><div class="line">for item in someInts &#123;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">for (index,item) in someInts.enumerated() &#123;</div><div class="line">    print(&quot;index = \(index),item = \(item)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var someDict = [Int: String]() //空字典</div><div class="line">ar someDic:[Int:String] = [1:&quot;one&quot;,2:&quot;two&quot;]</div><div class="line">someDic[1] = &quot;999&quot;</div><div class="line">someDic.updateValue(&quot;888&quot;, forKey: 1)</div><div class="line"></div><div class="line">someDic.count</div><div class="line">someDic.keys</div><div class="line">someDic.values</div><div class="line">someDic.isEmpty</div><div class="line"></div><div class="line">//遍历</div><div class="line">for (key,value) in someDic &#123;</div><div class="line">	print(&quot;key \(key),value \(value)&quot;)</div><div class="line">&#125;</div><div class="line">    </div><div class="line">for (key,value) in someDic.enumerated() &#123;</div><div class="line">	print(&quot;key \(key),value \(value)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h1><p>元组与数组类似,不同的是,元组中的元素可以是任意类型的,使用的是圆括号<br>(a:Int,b String)</p>
<p><span id="函数"></span></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">func minMax(array:[Int]) -&gt; (min: Int,max: Int) &#123;</div><div class="line">var currentMin = array[0];</div><div class="line">var currentMax = array[0]</div><div class="line">for value in array[1..&lt;array.count] &#123;</div><div class="line">    if value &lt; currentMin&#123;</div><div class="line">        currentMin = value</div><div class="line">    &#125;else if value &gt; currentMax&#123;</div><div class="line">        currentMax = value</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">return (currentMin,currentMax)</div><div class="line">&#125;</div><div class="line">//考虑参数为nil,返回一个可选的元组</div><div class="line">if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123;</div><div class="line">    print(&quot;最小值为 \(bounds.min)，组大值为 \(bounds.max)&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//没有返回值</div><div class="line">func runoob(site: String) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//firstArg外惨 a是局部参数,如果提供了外部参数名,那么函数在被调用时,必须使用外部参数名</div><div class="line">func pow(firstArg a:Int,secondArg b:Int) -&gt; Int&#123;</div><div class="line">    var res = a</div><div class="line">    for _ in 1..&lt;b &#123;</div><div class="line">        res = res * a</div><div class="line">    &#125;</div><div class="line">    print(res)</div><div class="line">    return res</div><div class="line">&#125;</div><div class="line"></div><div class="line">//可变参数</div><div class="line">//可变参数可以接受零个或多个值.函数调用时,你可以用可变参数来指定函数参数</div><div class="line">func vari&lt;N&gt;(members: N...) &#123;</div><div class="line">    for i in members &#123;</div><div class="line">        print(i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">vari(members: 4,3,5)</div><div class="line"></div><div class="line">//常量，变量及 I/O 参数</div><div class="line">//一般默认在函数中定义的参数都是参量参数,也就是这个参数你只可以参训使用,不能改变它的值.如果想要声明一个变量参数,可以在参数定义前加inout关键字,这样就可以改变这个参数的值了.</div><div class="line">func  getName(_ name: inout String).........</div><div class="line">一般默认的参数传递都是传值调用的,而不是传引用,所以传入的参数在函数内改变,并不影响原来的那个参数.传入的只是这个参数的副本</div><div class="line">但传入的参数作为输入输出参数时,需要在参数名钱加&amp;符,表示这个值可以被修改</div><div class="line">func swapTwoInts(_ a:inout Int,_ b:inout Int)&#123;</div><div class="line">    let temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div><div class="line">var x = 1</div><div class="line">var y = 5</div><div class="line">swapTwoInts(&amp;x, &amp;y)</div><div class="line">print(&quot;x现在的值\(x),y现在的值\(y)&quot;)</div><div class="line"></div><div class="line"></div><div class="line">//函数类型</div><div class="line">var addition: (Int,Int) -&gt;Int = sum;</div><div class="line">解析: 定义一个叫做addition的变量,参数与返回值类型都是Int,并让这个新变量指向sum函数.sum和addition有同样的类型/.</div><div class="line">func sum(a: Int,b:Int) -&gt;Int &#123;</div><div class="line">    return a+b;</div><div class="line">&#125;</div><div class="line">var addition: (Int,Int) -&gt; Int = sum</div><div class="line">print(&quot;输出结果:\(addition(40,89))&quot;)</div><div class="line"></div><div class="line">//函数类型用作参数和返回类型</div><div class="line">func another(addition: (Int, Int) -&gt; Int, a: Int, b: Int) &#123;</div><div class="line">    print(&quot;输出结果: \(addition(a, b))&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//函数嵌套</div><div class="line">//函数嵌套指的是函数内定义一个新的函数,外部的函数可以调用函数内定义的函数</div><div class="line">func calcDecrement(forDecrement total: Int) -&gt; () -&gt; Int &#123;</div><div class="line">    var overallDecrement = 0</div><div class="line">    func decrementer() -&gt; Int &#123;</div><div class="line">        overallDecrement -= total</div><div class="line">        return overallDecrement</div><div class="line">    &#125;</div><div class="line">    return decrementer;</div><div class="line">&#125;</div><div class="line">let decrem = calcDecrement(forDecrement: 30)</div><div class="line">print(decrem())</div></pre></td></tr></table></figure>
<p><span id="闭包"></span></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;(parameters) -&gt; return type in</div><div class="line">   statements</div><div class="line">&#125;</div><div class="line"></div><div class="line">let divide = &#123;(val1: Int, val2: Int) -&gt; Int in </div><div class="line">   return val1 / val2 </div><div class="line">&#125;</div><div class="line">let result = divide(200, 20)</div><div class="line">print (result)</div><div class="line"></div><div class="line">//sorted方法</div><div class="line">sorted(by:)方法需要传入两个参数:</div><div class="line">1. 已知类型的数组</div><div class="line">2. 闭包函数</div><div class="line"></div><div class="line">let names = [&quot;AT&quot;,&quot;AE&quot;,&quot;D&quot;,&quot;S&quot;,&quot;BE&quot;]</div><div class="line">func backwards(s1:String,s2:String) -&gt; Bool&#123;</div><div class="line">    return s1 &gt; s2</div><div class="line">&#125;</div><div class="line">var reversed = names.sorted(by: backwards)</div><div class="line">print(reversed)</div><div class="line"></div><div class="line">Swift的string类型定义了关于大于号(&gt;)的字符串实现,所以可以简写成</div><div class="line">var reversed = names.sorted(by: &gt;)</div></pre></td></tr></table></figure>
<p><strong>尾随闭包</strong></p>
<p>尾随闭包是一个书写在函数括号之后的闭包表达式,函数支持将其作为最后一个参数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">个参数调用</div><div class="line">func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123;</div><div class="line">    // 函数体部分</div><div class="line">    print(&quot;1&quot;);</div><div class="line">    closure();</div><div class="line">    print(&quot;3&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//以下是不适用尾随闭包进行函数调用</div><div class="line">someFunctionThatTakesAclosure(&#123;</div><div class="line">    //闭包主体部分</div><div class="line">    print(&quot;2&quot;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//以下是使用尾随闭包进行函数调用</div><div class="line">someFunctionThatTakesAClosure() &#123;</div><div class="line">  // 闭包主体部分</div><div class="line">  print(&quot;2&quot;);</div><div class="line">&#125;</div><div class="line">或是</div><div class="line">someFunctionThatTakesAClosure &#123;</div><div class="line">	print(&quot;2&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let names = [&quot;AT&quot;,&quot;AE&quot;,&quot;D&quot;,&quot;S&quot;,&quot;BE&quot;]</div><div class="line">        </div><div class="line">//尾随闭包</div><div class="line">var reversed = names.sorted()&#123;$0 &gt; $1&#125;</div><div class="line">print(reversed)</div><div class="line"></div><div class="line">//如果函数只需要闭包表达式一个参宿,当您使用尾随闭包时,可以把()省略</div><div class="line">reversed = names.sorted &#123; $0 &gt; $1 &#125;</div></pre></td></tr></table></figure>
<p><strong>捕获值</strong></p>
<p>闭包可以在其定义的上下文中捕获常量或变量.即使定义这些常量和变量的原域已经不存在,闭包仍然可以在闭包函数体内引用和修改这些值.swift最简单的闭包形式是嵌套函数,也就是定义在其他函数的函数体内的函数.嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量.看这个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func  makeIncrementor(forIncrement amount: Int) -&gt; ()-&gt;Int &#123;</div><div class="line">    var runningTotal = 0;</div><div class="line">    func incrementor() -&gt; Int&#123;</div><div class="line">        runningTotal += amount</div><div class="line">        return runningTotal</div><div class="line">    &#125;</div><div class="line">    return incrementor</div><div class="line">&#125;</div><div class="line">let incrementByTen = makeIncrementor(forIncrement: 10);</div><div class="line">print(incrementByTen());</div><div class="line">print(incrementByTen())</div><div class="line">print(incrementByTen())</div><div class="line">输入 10  20  30</div></pre></td></tr></table></figure>
<p>函数体内,声明了变量runningTotal和一个函数incrementor. incrementor函数并没有获取任何参数,但是在函数体内访问了runningTotal和amount变量.这是因为其通过捕获在包含他的函数体内已经存在的runningTotal和amount变量而实现.由于没有修改amount变量,incrementor实际上捕获并存储了改变量的一个副本,二该副本随着incrementor一同被存储.所以调用这个函数时会累加</p>
<p><strong>闭包是引用类型</strong></p>
<p>上面的例子中,incrementByTen是常量,但是这些常量指向的闭包仍然可以增加其捕获的变量值.这是因为函数和闭包都是引用类型.无论你讲函数/闭包赋值给一个常量还是变量,你实际上都是讲常量/变量的值设置为对应函数/闭包的引用.上面的例子中,incrementByTen指向闭包的引用是一个常量,而并非闭包内容本身.这也意味着如果你讲闭包赋值给两个不同的常量/变量,两个值都会指向同一个闭包</p>
<p><span id="枚举"></span></p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum DaysofaWeek &#123;</div><div class="line">    case Sunday</div><div class="line">    case Monday</div><div class="line">    case TUESDAY</div><div class="line">    case WEDNESDAY</div><div class="line">    case THURSDAY</div><div class="line">    case FRIDAY</div><div class="line">    case Saturday</div><div class="line">&#125;</div><div class="line">var weekDay = DaysofaWeek.THURSDAY</div><div class="line">weekDay = .THURSDAY //已经知道weekDay是DaysofaWeek类型后,之后的复制可以简写成这样</div></pre></td></tr></table></figure>
<p>Sunday，Monday是这个枚举的成员值.case关键词表示这一行的成员值将被定义.和C和OC不同,swift的枚举成员在被创建时不会被赋予一个默认的整型值.相反,这些枚举成员本身就有完备的值.这些值是已经明确定义好的DaysofaWeek</p>
<p><strong>相关值和原始值</strong></p>
<p>枚举可分为相关值和原始值</p>
<table>
<thead>
<tr>
<th>相关值</th>
<th>原始值</th>
</tr>
</thead>
<tbody>
<tr>
<td>不同的数据类型</td>
<td>相同的数据类型</td>
</tr>
<tr>
<td>enum {10,0.8,”Hello”}</td>
<td>enum {10,35,50}</td>
</tr>
<tr>
<td>值得创建基于常量或变量</td>
<td>预先填充的值</td>
</tr>
<tr>
<td>相关值是当在创建一个基于枚举成员的新常量或变量时才会被设置,并且每次当你这么做得实惠,它的值可以是不同的</td>
<td>原始值始终是相同的</td>
</tr>
</tbody>
</table>
<ul>
<li>1 相关值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">enum Student &#123;</div><div class="line">    case Name(String)</div><div class="line">    case Mark(Int,Int,Int)</div><div class="line">&#125;</div><div class="line">var studDetails = Student.Name(&quot;Runoob&quot;)</div><div class="line">var studMarks = Student.Mark(98, 97, 95)</div><div class="line">switch studMarks &#123;</div><div class="line">case .Name(let studName):</div><div class="line">    print(&quot;学生的名字是: \(studName)&quot;)</div><div class="line">case .Mark(let Mark1, let Mark2, let Mark3):</div><div class="line">    print(&quot;学生的成绩是: \(Mark1),\(Mark2),\(Mark3)。&quot;)</div><div class="line">&#125;</div><div class="line">输出    学生的成绩是: 98,97,95。</div></pre></td></tr></table></figure>
<ul>
<li>2 原始值</li>
</ul>
<p>原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。<br>在原始值为整数的枚举时，不需要显式的为每一个成员赋值，Swift会自动为你赋值。<br>例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个值没有被赋初值，将会被自动置为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">enum Month: Int &#123;</div><div class="line">        case January = 1, February, March, April, May, June, July, August, September, October, November, December</div><div class="line">&#125;</div><div class="line"></div><div class="line">let yearMonth = Month.May.rawValue</div><div class="line">print(&quot;数字月份为: \(yearMonth)。&quot;)</div><div class="line"></div><div class="line">输出:    数字月份为: 5。</div></pre></td></tr></table></figure>
<p><span id="结构体"></span></p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>与C和OC不同的是 :</p>
<ul>
<li>结构体不需要包含实现文件和接口</li>
<li>结构体允许我们创建一个单一文件,且系统工会自动生成面向其他代码的外部接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct studentMarks &#123;</div><div class="line">   var mark1 = 100</div><div class="line">   var mark2 = 78</div><div class="line">   var mark3 = 98</div><div class="line">&#125;</div><div class="line">let marks = studentMarks()</div><div class="line">print(&quot;Mark1 是 \(marks.mark1)&quot;)</div></pre></td></tr></table></figure>
<p><strong>结构体的应用</strong></p>
<p>结构体实例总是通过值传递来定义你的自定义数据类型.符合下面的一或多个条件可以考虑构建结构体: </p>
<ul>
<li>结构体的主要目的是用来封装少量相关简单的数据.</li>
<li>有理由预计一个结构体实例在复制或传递时,封装的数据将会被拷贝而不是被引用</li>
<li>任何结构体中储存的值类型属性,也将会被拷贝,而不是被引用</li>
<li>结构体不需要去集成另一个已存在的类型的属性或行为</li>
</ul>
<p>举例来说,以下情景适合使用结构体:</p>
<ul>
<li>几何形状的大小，封装一个width属性和height属性，两者均为Double类型</li>
<li>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。</li>
<li>三维坐标系内一点，封装x，y和z属性，三者均为Double类型 </li>
</ul>
<p>结构体实例是通过值传递而不是通过引用传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">struct markStruct&#123;</div><div class="line">    var mark1: Int</div><div class="line">    var mark2: Int</div><div class="line">    var mark3: Int</div><div class="line">    </div><div class="line">    init(mark1: Int, mark2: Int, mark3: Int)&#123;</div><div class="line">        self.mark1 = mark1</div><div class="line">        self.mark2 = mark2</div><div class="line">        self.mark3 = mark3</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">print(&quot;优异成绩:&quot;)</div><div class="line">var marks = markStruct(mark1: 98, mark2: 96, mark3:100)</div><div class="line">print(marks.mark1)</div><div class="line">print(marks.mark2)</div><div class="line">print(marks.mark3)</div><div class="line">    </div><div class="line">print(&quot;糟糕成绩:&quot;)</div><div class="line">var fail = markStruct(mark1: 34, mark2: 42, mark3: 13)</div><div class="line">print(fail.mark1)</div><div class="line">print(fail.mark2)</div><div class="line">print(fail.mark3)</div><div class="line"></div><div class="line">输出:</div><div class="line">优异成绩:</div><div class="line">98</div><div class="line">96</div><div class="line">100</div><div class="line">糟糕成绩:</div><div class="line">34</div><div class="line">42</div><div class="line">13</div></pre></td></tr></table></figure>
<p>以上实例中我们定义了结构体 markStruct，三个成员属性：mark1, mark2 和 mark3。结构体内使用成员属性使用 self 关键字。</p>
<p><span id="类"></span></p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>与其他编程语言所不同的是，Swift 并不要求你为自定义类去创建独立的接口和实现文件。你所要做的是在一个单一文件中定义一个类，系统会自动生成面向其它代码的外部接口。</p>
<p>类定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class student&#123;</div><div class="line">    var studname: String = &quot;&quot;</div><div class="line">    var mark: Int = 0</div><div class="line">    var mark2: Int = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let studrecord = student()</div></pre></td></tr></table></figure>
<p>属性访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class studentMarks &#123;</div><div class="line">   var mark1 = 300</div><div class="line">   var mark2 = 400</div><div class="line">   var mark3 = 900</div><div class="line">&#125;</div><div class="line">let marks = studentMarks()</div><div class="line">print(&quot;Mark1 is \(marks.mark1)&quot;)</div><div class="line">print(&quot;Mark2 is \(marks.mark2)&quot;)</div><div class="line">print(&quot;Mark3 is \(marks.mark3)&quot;)</div></pre></td></tr></table></figure>
<p><strong>恒等运算符</strong></p>
<table>
<thead>
<tr>
<th>恒等运算符</th>
<th>不恒等运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算符为 ===</td>
<td>运算符为 !==</td>
</tr>
<tr>
<td>如果两个常量或者变量引用同一个类实例则返回true</td>
<td>如果两个常量或者变量引用不同一个类型实例则返回 true</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let spClass1 = SampleClass(s: &quot;Hello&quot;);</div><div class="line">let spClass2 = SampleClass(s: &quot;Hello&quot;)</div><div class="line">    </div><div class="line">if spClass1 === spClass2 &#123;// false</div><div class="line">    print(&quot;引用相同的类实例 \(spClass1)&quot;)</div><div class="line">&#125;</div><div class="line">    </div><div class="line">if spClass1 !== spClass2 &#123;// true</div><div class="line">    print(&quot;引用不相同的类实例 \(spClass2)&quot;)</div><div class="line">&#125;</div><div class="line">输入:   引用不相同的类实例 SampleClass</div></pre></td></tr></table></figure>
<p><span id="属性"></span></p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>swift属性将值跟特定的类,结构或枚举关联</p>
<table>
<thead>
<tr>
<th>存储属性</th>
<th>计算属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储常量或变量作为实例的一部分</td>
<td>计算（而不是存储）一个值</td>
</tr>
<tr>
<td>用于类和结构体</td>
<td>用于类、结构体和枚举</td>
</tr>
</tbody>
</table>
<p><strong>存储属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct Number</div><div class="line">&#123;</div><div class="line">   var digits: Int</div><div class="line">   let pi = 3.1415</div><div class="line">&#125;</div><div class="line"></div><div class="line">var n = Number(digits: 12345)</div><div class="line">n.digits = 67</div><div class="line"></div><div class="line">print(&quot;\(n.digits)&quot;)</div><div class="line">print(&quot;\(n.pi)&quot;)</div></pre></td></tr></table></figure>
<p><strong>延迟存储属性</strong></p>
<p>在属性声明前使用lazy来标示一个延迟存储属性  属性必须声明成var</p>
<p>延迟存储属性一般用于:</p>
<ul>
<li>延迟对象的创建</li>
<li>当属性的值依赖于其他未知类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class sample&#123;</div><div class="line">    lazy var no = number();</div><div class="line">&#125;</div><div class="line">    </div><div class="line">class number&#123;</div><div class="line">    var name = &quot;runoob swift&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var firstsample = sample()</div><div class="line">print(firstsample.no.name)</div></pre></td></tr></table></figure>
<p><strong>计算属性</strong></p>
<p>计算属性不直接存储值,而是提供一个getter来获取值,一个可选的setter来间接设置其他属性或变量的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class sample &#123;</div><div class="line">    var no1 = 0.0, no2 = 0.0</div><div class="line">    var length = 300.0, breadth = 150.0</div><div class="line">    </div><div class="line">    var middle: (Double, Double) &#123;</div><div class="line">        get&#123;</div><div class="line">            return (length / 2, breadth / 2)</div><div class="line">        &#125;</div><div class="line">        set(axis)&#123;</div><div class="line">            no1 = axis.0 - (length / 2)</div><div class="line">            no2 = axis.1 - (breadth / 2)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result = sample()</div><div class="line">print(result.middle)</div><div class="line">result.middle = (0.0, 10.0)</div><div class="line"></div><div class="line">print(result.no1)</div><div class="line">print(result.no2)</div></pre></td></tr></table></figure>
<p><strong>只读计算属性</strong></p>
<p>只读计算属性总是返回一个值,可以通过点(.)运算符访问,但不能设置新的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class film &#123;</div><div class="line">    var head = &quot;&quot;</div><div class="line">    var duration = 0.0</div><div class="line">    var metaInfo: [String:String] &#123;</div><div class="line">        return [</div><div class="line">            &quot;head&quot;: self.head,</div><div class="line">            &quot;duration&quot;:&quot;\(self.duration)&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var movie = film()</div><div class="line">movie.head = &quot;Swift 属性&quot;</div><div class="line">movie.duration = 3.09</div><div class="line"></div><div class="line">print(movie.metaInfo[&quot;head&quot;]!)</div><div class="line">print(movie.metaInfo[&quot;duration&quot;]!)</div></pre></td></tr></table></figure>
<p><strong>属性观察器</strong></p>
<p>注意: 不需要为无法重载的计算属性添加属性观察器,以为可以通过setter直接监控和响应值得变化</p>
<p>可以为属性添加如下的一个或全部观察器</p>
<ul>
<li>willSet在设置新值之前调用</li>
<li>didSet在新的值被设置之后立即调用</li>
<li>willSet和didSet观察器在属性初始化过程中不回被调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Samplepgm &#123;</div><div class="line">    var counter: Int = 0&#123;</div><div class="line">        willSet(newTotal)&#123;</div><div class="line">            print(&quot;计数器: \(newTotal)&quot;)</div><div class="line">        &#125;</div><div class="line">        didSet&#123;</div><div class="line">            if counter &gt; oldValue &#123;</div><div class="line">                print(&quot;新增数 \(counter - oldValue)&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let NewCounter = Samplepgm()</div><div class="line">NewCounter.counter = 100</div><div class="line">NewCounter.counter = 800</div><div class="line"></div><div class="line">输出:</div><div class="line">计数器: 100</div><div class="line">新增数 100</div><div class="line">计数器: 800</div><div class="line">新增数 700</div></pre></td></tr></table></figure>
<p><strong>类型属性</strong></p>
<p>类型属性是作为类型定义的一部分写在类型最外层的花括号{}内.<br>使用关键字static来定义值类型的类型属性,关键字class来为类定义类型属性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct Structname &#123;</div><div class="line">   static var storedTypeProperty = &quot; &quot;</div><div class="line">   static var computedTypeProperty: Int &#123;</div><div class="line">      // 这里返回一个 Int 值</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Enumname &#123;</div><div class="line">   static var storedTypeProperty = &quot; &quot;</div><div class="line">   static var computedTypeProperty: Int &#123;</div><div class="line">      // 这里返回一个 Int 值</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Classname &#123;</div><div class="line">   class var computedTypeProperty: Int &#123;</div><div class="line">      // 这里返回一个 Int 值</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>获取和设置类型属性的值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">struct StudMarks &#123;</div><div class="line">   static let markCount = 97</div><div class="line">   static var totalCount = 0</div><div class="line">   var InternalMarks: Int = 0 &#123;</div><div class="line">      didSet &#123;</div><div class="line">         if InternalMarks &gt; StudMarks.markCount &#123;</div><div class="line">            InternalMarks = StudMarks.markCount</div><div class="line">         &#125;</div><div class="line">         if InternalMarks &gt; StudMarks.totalCount &#123;</div><div class="line">            StudMarks.totalCount = InternalMarks</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var stud1Mark1 = StudMarks()</div><div class="line">var stud1Mark2 = StudMarks()</div><div class="line"></div><div class="line">stud1Mark1.InternalMarks = 98</div><div class="line">print(stud1Mark1.InternalMarks) </div><div class="line"></div><div class="line">stud1Mark2.InternalMarks = 87</div><div class="line">print(stud1Mark2.InternalMarks)</div></pre></td></tr></table></figure>
<p><span id="方法"></span></p>
<h1 id="swift方法"><a href="#swift方法" class="headerlink" title="swift方法"></a>swift方法</h1><p><strong>在实例方法中修改值类型</strong></p>
<p>swift语言中结构体和枚举是值类型.一般情况下,值类型的属性不能在它的的实例方法中被修改.<br>但是,如果你确实需要在某个具体的方法中修改结构体或者枚举的属性,你可以选择变异(mutating)这个方法,然后方法就可以从方法内部改变它的属性;并且它做的任何改变在方法结束时还会保留在原始结构中.<br>方法还可以给它隐含的属性赋值一个全新的实例,这个新实例在方法结束后替换原来的实例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">struct area &#123;</div><div class="line">    var length = 1</div><div class="line">    var breadth = 1</div><div class="line">    </div><div class="line">    func area() -&gt; Int &#123;</div><div class="line">        return length * breadth</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mutating func scaleBy(res: Int) &#123;</div><div class="line">        length *= res</div><div class="line">        breadth *= res</div><div class="line">        </div><div class="line">        print(length)</div><div class="line">        print(breadth)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var val = area(length: 3, breadth: 5)</div><div class="line">val.scaleBy(res: 3)</div><div class="line">val.scaleBy(res: 30)</div><div class="line"></div><div class="line">输出: </div><div class="line">9</div><div class="line">15</div><div class="line">270</div><div class="line">450</div></pre></td></tr></table></figure>
<p><strong>类型方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Math</div><div class="line">&#123;</div><div class="line">    class func abs(number: Int) -&gt; Int</div><div class="line">    &#123;</div><div class="line">        if number &lt; 0</div><div class="line">        &#123;</div><div class="line">            return (-number)</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            return number</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct absno</div><div class="line">&#123;</div><div class="line">    static func abs(number: Int) -&gt; Int</div><div class="line">    &#123;</div><div class="line">        if number &lt; 0</div><div class="line">        &#123;</div><div class="line">            return (-number)</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            return number</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let no = Math.abs(number: -35)</div><div class="line">let num = absno.abs(number: -5)</div><div class="line"></div><div class="line">print(no)</div><div class="line">print(num)</div><div class="line"></div><div class="line">输出: </div><div class="line">35</div><div class="line">5</div></pre></td></tr></table></figure>
<p><span id="下标脚本"></span></p>
<h1 id="swift下标脚本"><a href="#swift下标脚本" class="headerlink" title="swift下标脚本"></a>swift下标脚本</h1><p>下标脚本 可以定义在类(Class),结构体(stucture)和枚举(enumeration)这些目标中,可以认为是访问对象,集合或序列的快捷方式.someDictionary[key],someArray[index]</p>
<p><strong>语法及应用</strong></p>
<p>下标脚本允许你通过在实例后面的方括号中传入一个或者多个索引值来对实例进行访问和赋值.</p>
<p>语法类似于实例方法和计算型属性的混合.</p>
<p>与定义实例方法类似,定义下标脚本使用subscript关键字,显式声明入参(一个或多个)和返回类型,</p>
<p>与实例方法不同的是下标脚本可以设定为读写或只读.这种方式又有点像计算型属性的setter和getter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct subexample &#123;</div><div class="line">    let decrementer: Int</div><div class="line">    subscript(index: Int) -&gt; Int &#123;</div><div class="line">        return decrementer / index</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let division = subexample(decrementer: 100)</div><div class="line"></div><div class="line">print(&quot;100 除以 9 等于 \(division[9])&quot;)</div><div class="line">print(&quot;100 除以 2 等于 \(division[2])&quot;)</div><div class="line">print(&quot;100 除以 3 等于 \(division[3])&quot;)</div><div class="line">print(&quot;100 除以 5 等于 \(division[5])&quot;)</div><div class="line">print(&quot;100 除以 7 等于 \(division[7])&quot;)</div><div class="line"></div><div class="line">输出:</div><div class="line">100 除以 9 等于 11</div><div class="line">100 除以 2 等于 50</div><div class="line">100 除以 3 等于 33</div><div class="line">100 除以 5 等于 20</div><div class="line">100 除以 7 等于 14</div><div class="line"></div><div class="line">//通过下标脚本来得到结果，比如 division[2] 即为 100 除以 2。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class daysofaweek &#123;</div><div class="line">    private var days = [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,</div><div class="line">        &quot;Thursday&quot;, &quot;Friday&quot;, &quot;saturday&quot;]</div><div class="line">    subscript(index: Int) -&gt; String &#123;</div><div class="line">        get &#123;</div><div class="line">            return days[index]   // 声明下标脚本的值</div><div class="line">        &#125;</div><div class="line">        set(newValue) &#123;</div><div class="line">            self.days[index] = newValue   // 执行赋值操作</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var p = daysofaweek()</div><div class="line"></div><div class="line">print(p[0])</div><div class="line">print(p[1])</div><div class="line">print(p[2])</div><div class="line">print(p[3])</div><div class="line"></div><div class="line">输出: </div><div class="line">Sunday</div><div class="line">Monday</div><div class="line">Tuesday</div><div class="line">Wednesday</div></pre></td></tr></table></figure>
<p><strong>下标脚本选项</strong></p>
<ul>
<li>下标脚本允许任意数量的入参索引,并且每个入参类型也没有限制.</li>
<li>下标脚本的返回值也可以是任何类型</li>
<li>下标脚本可以使用变量参数和可变参数</li>
<li>一个类或结构体可以根据机身需要提供多个下标脚本实现,在定义下标脚本时通过入参数的类型进行区分,使用下标脚本时会自动匹配合适的下标脚本实现运行,这就是<strong>下标脚本的重载</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct Matrix &#123;</div><div class="line">    let rows: Int, columns: Int</div><div class="line">    var print: [Double]</div><div class="line">    init(rows: Int, columns: Int) &#123;</div><div class="line">        self.rows = rows</div><div class="line">        self.columns = columns</div><div class="line">        print = Array(repeating: 0.0, count: rows * columns)</div><div class="line">    &#125;</div><div class="line">    subscript(row: Int, column: Int) -&gt; Double &#123;</div><div class="line">        get &#123;</div><div class="line">            return print[(row * columns) + column]</div><div class="line">        &#125;</div><div class="line">        set &#123;</div><div class="line">            print[(row * columns) + column] = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 创建了一个新的 3 行 3 列的Matrix实例</div><div class="line">var mat = Matrix(rows: 3, columns: 3)</div><div class="line"></div><div class="line">// 通过下标脚本设置值</div><div class="line">mat[0,0] = 1.0</div><div class="line">mat[0,1] = 2.0</div><div class="line">mat[1,0] = 3.0</div><div class="line">mat[1,1] = 5.0</div><div class="line"></div><div class="line">// 通过下标脚本获取值</div><div class="line">print(&quot;\(mat[0,0])&quot;)</div><div class="line">print(&quot;\(mat[0,1])&quot;)</div><div class="line">print(&quot;\(mat[1,0])&quot;)</div><div class="line">print(&quot;\(mat[1,1])&quot;)</div></pre></td></tr></table></figure>
<p><span id="继承"></span></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>关键字 override</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class SuperClass &#123;</div><div class="line">    func show() &#123;</div><div class="line">        print(&quot;这是超类 SuperClass&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SubClass: SuperClass  &#123;</div><div class="line">    override func show() &#123;</div><div class="line">        print(&quot;这是子类 SubClass&quot;)</div><div class="line">        super.show()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let superClass = SuperClass()</div><div class="line">superClass.show()</div><div class="line"></div><div class="line">let subClass = SubClass()</div><div class="line">subClass.show()</div><div class="line"></div><div class="line">输出: </div><div class="line">这是超类 SuperClass</div><div class="line">这是子类 SubClass</div><div class="line">这是超类 SuperClass</div></pre></td></tr></table></figure>
<p><strong>重写属性</strong></p>
<ul>
<li>如果你在重写舒心各种提供了setter,那么你也一定要提供getter</li>
<li>如果你不想再重写版本中的getter离修改继承来的属性值,你可以直接通过super.someProperty来返回继承来的值,之中someProperty是你要重写的属性的名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class Circle &#123;</div><div class="line">    var radius = 12.5</div><div class="line">    var area: String &#123;</div><div class="line">        return &quot;矩形半径为 \(radius) &quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Rectangle: Circle &#123;</div><div class="line">    var print = 7</div><div class="line">    override var area: String &#123;</div><div class="line">        return super.area + &quot; ，但现在被重写为 \(print)&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">let rect = Rectangle()</div><div class="line">rect.radius = 25.0</div><div class="line">rect.print = 3</div><div class="line">print(&quot;半径: \(rect.area)&quot;)</div><div class="line"></div><div class="line">class Square: Rectangle &#123;</div><div class="line">    override var radius: Double &#123;</div><div class="line">        didSet &#123;</div><div class="line">            print = Int(radius/5.0)+1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let sq = Square()</div><div class="line">sq.radius = 100.0</div><div class="line">print(&quot;半径: \(sq.area)&quot;)</div><div class="line"></div><div class="line">输出: </div><div class="line">半径: 矩形半径为 25.0  ，但现在被重写为 3</div><div class="line">半径: 矩形半径为 100.0  ，但现在被重写为 21</div></pre></td></tr></table></figure>
<p><strong>防止重写</strong></p>
<p>关键字 final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final class Circle &#123;</div><div class="line">    final var radius = 12.5</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="构造,析构,可选链"></span></p>
<h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h1><p><strong>可选属性类型</strong></p>
<p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性,要讲它定义为可选类型optional type(可选属性类型)</p>
<p>当存储属性声明为可选时,将自动初始化为nil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct Rectangle &#123;</div><div class="line">    let length: Double?</div><div class="line">    </div><div class="line">    init(frombreadth breadth: Double) &#123;</div><div class="line">        length = breadth * 10</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    init(frombre bre: Double) &#123;</div><div class="line">        length = bre * 30</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    init(_ area: Double) &#123;</div><div class="line">        length = area</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let rectarea = Rectangle(180.0)</div><div class="line">print(&quot;面积为：\(rectarea.length)&quot;)</div><div class="line">输出:</div><div class="line">面积为：Optional(180.0)</div></pre></td></tr></table></figure>
<p>只要在构造过程结束前常量的值能确定, 你可以在构造过程中的任意时间点修改常量属性的值.</p>
<p>对于某个类实例来说,他的常量属性只能在定义的类的构造过程中修改;不能再子类中修改.</p>
<p>尽管length属性现在是常量,我们仍然可以在其类的构造器中设置它的值,上面的例子就是</p>
<p><strong>默认构造器</strong></p>
<p>如果结构体对所有存储型属性提供了默认值且自身没有提供定制的构造器,它们能自动获得一个<strong>逐一成员构造器</strong>.我们在调用逐一成员构造器时,通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Rectangle &#123;</div><div class="line">    var length = 100.0, breadth = 200.0</div><div class="line">&#125;</div><div class="line">let area = Rectangle(length: 24.0, breadth: 32.0)</div></pre></td></tr></table></figure>
<p>结构体 Rectangle 自动获得了一个逐一成员构造器 init(width:height:)。 你可以用它来为 Rectangle 创建新的实例。</p>
<p><strong>值类型的构造器代理</strong></p>
<p>构造器可以通过调用其他构造器来完成实例的部分构造过程.这一过程称为构造器搭理,它能减少多个构造器间的代码重复.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">struct Size &#123;</div><div class="line">    var width = 0.0, height = 0.0</div><div class="line">&#125;</div><div class="line">struct Point &#123;</div><div class="line">    var x = 0.0, y = 0.0</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Rect &#123;</div><div class="line">    var origin = Point()</div><div class="line">    var size = Size()</div><div class="line">    init() &#123;&#125;</div><div class="line">    init(origin: Point, size: Size) &#123;</div><div class="line">        self.origin = origin</div><div class="line">        self.size = size</div><div class="line">    &#125;</div><div class="line">    init(center: Point, size: Size) &#123;</div><div class="line">        let originX = center.x - (size.width / 2)</div><div class="line">        let originY = center.y - (size.height / 2)</div><div class="line">        self.init(origin: Point(x: originX, y: originY), size: size)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">let basicRect = Rect()</div><div class="line">print(&quot;Size 结构体初始值: \(basicRect.size.width, basicRect.size.height) &quot;)</div><div class="line">print(&quot;Rect 结构体初始值: \(basicRect.origin.x, basicRect.origin.y) &quot;)</div><div class="line"></div><div class="line">let originRect = Rect(origin: Point(x: 2.0, y: 2.0),</div><div class="line">    size: Size(width: 5.0, height: 5.0))</div><div class="line"></div><div class="line">print(&quot;Size 结构体初始值: \(originRect.size.width, originRect.size.height) &quot;)</div><div class="line">print(&quot;Rect 结构体初始值: \(originRect.origin.x, originRect.origin.y) &quot;)</div><div class="line"></div><div class="line"></div><div class="line">//先通过center和size的值计算出origin的坐标。</div><div class="line">//然后再调用（或代理给）init(origin:size:)构造器来将新的origin和size值赋值到对应的属性中</div><div class="line">let centerRect = Rect(center: Point(x: 4.0, y: 4.0),</div><div class="line">    size: Size(width: 3.0, height: 3.0))</div><div class="line"></div><div class="line">print(&quot;Size 结构体初始值: \(centerRect.size.width, centerRect.size.height) &quot;)</div><div class="line">print(&quot;Rect 结构体初始值: \(centerRect.origin.x, centerRect.origin.y) &quot;)</div></pre></td></tr></table></figure>
<p>构造器代理规则</p>
<p><strong>值类型</strong> :不支持继承,所有构造器代理的过程相对简单,因为它们只能代理给本身提供的其他构造器.你可以使用self.init在自定义的构造器中引用其他的属于相同值类型的构造器.</p>
<p><strong>类类型</strong> :它可以继承自其他类,这以为着类有责任保证其所有继承的存储属性在构造时也能正确的初始化.</p>
<p><strong>指定构造器</strong>就是普通的构造器</p>
<p><strong>便利构造器</strong></p>
<p>可以定义便利构造器来调用同一个类中的指定构造器,并未其参数提供默认值.你也可以定义便利构造器来创建一个特殊用途或特定输入的实例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class mainClass &#123;</div><div class="line">    var no1 : Int // 局部存储变量</div><div class="line">    init(no1 : Int) &#123;</div><div class="line">        self.no1 = no1 // 初始化</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class subClass : mainClass &#123;</div><div class="line">    var no2 : Int</div><div class="line">    init(no1 : Int, no2 : Int) &#123;</div><div class="line">        self.no2 = no2</div><div class="line">        super.init(no1:no1)</div><div class="line">    &#125;</div><div class="line">    // 便利方法只需要一个参数</div><div class="line">    override convenience init(no1: Int)  &#123;</div><div class="line">        self.init(no1:no1, no2:0)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let res = mainClass(no1: 20)</div><div class="line">let res2 = subClass(no1: 30, no2: 50)</div><div class="line"></div><div class="line">print(&quot;res 为: \(res.no1)&quot;)</div><div class="line">print(&quot;res2 为: \(res2.no1)&quot;)</div><div class="line">print(&quot;res2 为: \(res2.no2)&quot;)</div></pre></td></tr></table></figure>
<p><strong>类的可失败构造器</strong></p>
<p>语法为在init关键字后面加添问号(init?)<br>或是(init!)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct Animal &#123;</div><div class="line">    let species: String</div><div class="line">    init?(species:String)&#123;</div><div class="line">        if species.isEmpty&#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">        self.species=species</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">let somecreature = Animal(species:&quot;&quot;)</div></pre></td></tr></table></figure>
<h1 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h1><p><strong>注意</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Outer &#123;</div><div class="line">    let value = &quot;5555&quot;</div><div class="line">    var inner = Inner()</div><div class="line">    </div><div class="line">    func fooo() &#123;</div><div class="line">        inner.foo()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    class Inner &#123;</div><div class="line">        weak var parent: Outer! = nil</div><div class="line">        func foo() &#123;</div><div class="line">            let bar = parent.value</div><div class="line">            print(parent.value)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    init() &#123;</div><div class="line">        inner.parent = self</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">var outer = Outer()</div><div class="line">outer.fooo()</div><div class="line"></div><div class="line">输出:</div><div class="line">5555</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Outer_m &#123;</div><div class="line">    var counter = 0</div><div class="line">    var inner :Inner_m? = Inner_m()</div><div class="line">    class Inner_m &#123;</div><div class="line">        weak var outer: Outer_m! = nil</div><div class="line">        init()&#123;</div><div class="line">//                outer.counter += 1 // 这样会报错,  因为Inner_m的init先于Outer_m的init执行</div><div class="line">        &#125;</div><div class="line">        func be()&#123;</div><div class="line">            outer.counter += 1</div><div class="line">        &#125;</div><div class="line">        deinit &#123;</div><div class="line">            outer.counter -= 1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    init()&#123;</div><div class="line">        inner?.outer = self</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func foo()&#123;</div><div class="line">        inner?.be()</div><div class="line">        print(counter)</div><div class="line">        inner = nil</div><div class="line">        print(counter)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链 ? !"></a>可选链 ? !</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    var residence: Residence?</div><div class="line">&#125;</div><div class="line">    </div><div class="line">class Residence &#123;</div><div class="line">    var numberOfRooms = 1</div><div class="line">&#125;</div><div class="line">    </div><div class="line">let john = Person()</div><div class="line">    </div><div class="line">//将导致运行时错误</div><div class="line">//        let roomCount = john.residence!.numberOfRooms</div></pre></td></tr></table></figure>
<p>想使用感叹号（!）强制解析获得这个人residence属性numberOfRooms属性值，将会引发运行时错误，因为这时没有可以供解析的residence值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 链接可选residence?属性，如果residence存在则取回numberOfRooms的值</div><div class="line">if let roomCount = john.residence?.numberOfRooms &#123;</div><div class="line">    print(&quot;John 的房间号为 \(roomCount)。&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;不能查看房间号&quot;)</div><div class="line">&#125;</div><div class="line">输出: 不能查看房间号</div></pre></td></tr></table></figure>
<p>因为这种尝试获得numberOfRooms的操作有可能失败，可选链会返回Int?类型值，或者称作”可选Int”。当residence是空的时候（上例），选择Int将会为空，因此会出现无法访问numberOfRooms的情况。<br>要注意的是，即使numberOfRooms是非可选Int（Int?）时这一点也成立。只要是通过可选链的请求就意味着最后numberOfRooms总是返回一个Int?而不是Int。</p>
<p><span id="自动引用计数"></span></p>
<h1 id="自动引用计数-ARC"><a href="#自动引用计数-ARC" class="headerlink" title="自动引用计数(ARC)"></a>自动引用计数(ARC)</h1><p><strong>解决实例之间循环强引用</strong> :</p>
<ul>
<li>若引用</li>
<li>无主引用</li>
</ul>
<p>弱引用实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Module &#123;</div><div class="line">    let name: String</div><div class="line">    init(name: String) &#123; self.name = name &#125;</div><div class="line">    var sub: SubModule?</div><div class="line">    deinit &#123; print(&quot;\(name) 主模块&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SubModule &#123;</div><div class="line">    let number: Int</div><div class="line">    </div><div class="line">    init(number: Int) &#123; self.number = number &#125;</div><div class="line">    </div><div class="line">    weak var topic: Module?</div><div class="line">    </div><div class="line">    deinit &#123; print(&quot;子模块 topic 数为 \(number)&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var toc: Module?</div><div class="line">var list: SubModule?</div><div class="line">toc = Module(name: &quot;ARC&quot;)</div><div class="line">list = SubModule(number: 4)</div><div class="line">toc!.sub = list</div><div class="line">list!.topic = toc</div><div class="line"></div><div class="line">toc = nil</div><div class="line">list = nil</div><div class="line"></div><div class="line">输出:</div><div class="line">ARC 主模块</div><div class="line">子模块 topic 数为 4</div><div class="line">``` </div><div class="line"></div><div class="line">无主引用实例</div></pre></td></tr></table></figure>
<p>class Student {<br>    let name: String<br>    var section: Marks?</p>
<pre><code>init(name: String) {
    self.name = name
}

deinit { print(&quot;\(name)&quot;) }
</code></pre><p>}<br>class Marks {<br>    let marks: Int<br>    unowned let stname: Student</p>
<pre><code>init(marks: Int, stname: Student) {
    self.marks = marks
    self.stname = stname
}

deinit { print(&quot;学生的分数为 \(marks)&quot;) }
</code></pre><p>}</p>
<p>var module: Student?<br>module = Student(name: “ARC”)<br>module!.section = Marks(marks: 98, stname: module!)<br>module = nil</p>
<p>输出:<br>ARC<br>学生的分数为 98<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**解决闭包引起的循环强引用**</div><div class="line"></div><div class="line">当闭包和捕获的实例总是相互引用时并且总是同时销毁时,将闭包内的捕获定义为无主引用.</div><div class="line"></div><div class="line">相反的,当捕获引用有时可能会为nil时,将闭包内的捕获定义为弱引用.</div><div class="line"></div><div class="line">如果捕获的引用绝对不会置为nil,应该用无主引用,而不是弱引用.</div><div class="line"></div><div class="line">``</div><div class="line">class HTMLElement &#123;</div><div class="line">    </div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line">    </div><div class="line">    lazy var asHTML: () -&gt; String = &#123;</div><div class="line">        [unowned self] in</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125; else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name) 被析构&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建并打印HTMLElement实例</div><div class="line">var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)</div><div class="line">print(paragraph!.asHTML())</div><div class="line"></div><div class="line">// HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息</div><div class="line">paragraph = nil</div><div class="line"></div><div class="line">输出:</div><div class="line">&lt;p&gt;hello, world&lt;/p&gt;</div><div class="line">p 被析构</div><div class="line">``</div><div class="line"></div><div class="line">&lt;span id=&quot;类型转换&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">swift类型转换</div><div class="line">==============</div><div class="line"></div><div class="line">swift中类型转换使用is和as操作符实现,is用于检测值得类型,as用于转换类型.</div><div class="line"></div><div class="line">类型转换也可以用来检查一个类是否实现了某个协议.</div><div class="line"></div><div class="line">操作符is来检查一个实例是否属于特定子类型.</div></pre></td></tr></table></figure></p>
<p>class Subjects {<br>    var physics: String<br>    init(physics: String) {<br>        self.physics = physics<br>    }<br>}</p>
<p>class Chemistry: Subjects {<br>    var equations: String<br>    init(physics: String, equations: String) {<br>        self.equations = equations<br>        super.init(physics: physics)<br>    }<br>}</p>
<p>class Maths: Subjects {<br>    var formulae: String<br>    init(physics: String, formulae: String) {<br>        self.formulae = formulae<br>        super.init(physics: physics)<br>    }<br>}</p>
<p>let sa = [<br>    Chemistry(physics: “固体物理”, equations: “赫兹”),<br>    Maths(physics: “流体动力学”, formulae: “千兆赫”),<br>    Chemistry(physics: “热物理学”, equations: “分贝”),<br>    Maths(physics: “天体物理学”, formulae: “兆赫”),<br>    Maths(physics: “微分方程”, formulae: “余弦级数”)]</p>
<p>var chemCount = 0<br>var mathsCount = 0<br>for item in sa {<br>    // 如果是一个 Chemistry 类型的实例，返回 true，相反返回 false。<br>    if item is Chemistry {<br>        ++chemCount<br>    } else if item is Maths {<br>        ++mathsCount<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**向下转型** :操作符 as? 或 as!</div><div class="line"></div><div class="line">当你不确定向下转型可以成功时,用类型转换的条件形式(as?).条件形式的类型转换总是返回一个可选值(optional value),并且若下转是不可能的,可选值将是nil.</div><div class="line"></div><div class="line">只有你可以确定想下转型一定会成功时,才使用强制形式(as!).当你试图下转类型为一个不正确的类型是,强制的类型转换会触发一个运行时错误.</div></pre></td></tr></table></figure>
<p>for item in sa {<br>    // 类型转换的条件形式<br>    if let show = item as? Chemistry {<br>        print(“化学主题是: ‘(show.physics)’, (show.equations)”)<br>        // 强制形式<br>    } else if let example = item as? Maths {<br>        print(“数学主题是: ‘(example.physics)’,  (example.formulae)”)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**Any和AnyObject的类型转换**</div><div class="line"></div><div class="line">* AnyObject可以代表任何class的实例.</div><div class="line">* Any可以表示任何类型,包括方法类型(function types)</div></pre></td></tr></table></figure></p>
<p>// 可以存储Any类型的数组 exampleany<br>var exampleany = <a href="">Any</a></p>
<p>exampleany.append(12)<br>exampleany.append(3.14159)<br>exampleany.append(“Any 实例”)<br>exampleany.append(Chemistry(physics: “固体物理”, equations: “兆赫”))</p>
<p>for item2 in exampleany {<br>    switch item2 {<br>    case let someInt as Int:<br>        print(“整型值为 (someInt)”)<br>    case let someDouble as Double where someDouble &gt; 0:<br>        print(“Pi 值为 (someDouble)”)<br>    case let someString as String:<br>        print(“(someString)”)<br>    case let phy as Chemistry:<br>        print(“主题 ‘(phy.physics)’, (phy.equations)”)<br>    default:<br>        print(“None”)<br>    }<br>}</p>
<p>输出:<br>整型值为 12<br>Pi 值为 3.14159<br>Any 实例<br>主题 ‘固体物理’, 兆赫<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// [AnyObject] 类型的数组<br>let saprint: [AnyObject] = [<br>    Chemistry(physics: “固体物理”, equations: “赫兹”),<br>    Maths(physics: “流体动力学”, formulae: “千兆赫”),<br>    Chemistry(physics: “热物理学”, equations: “分贝”),<br>    Maths(physics: “天体物理学”, formulae: “兆赫”),<br>    Maths(physics: “微分方程”, formulae: “余弦级数”)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在一个switch语句的case中使用强制形式的类型转换操作符(as,而不是as?)来检查和转换到一个明确的类型.</div><div class="line"></div><div class="line">&lt;span id=&quot;扩展&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">扩展</div><div class="line">==============</div><div class="line"></div><div class="line">* 添加计算型属性和计算型静态属性</div><div class="line">* 定义实例方法和类型方法</div><div class="line">* 提供新的构造器</div><div class="line">* 定义下标</div><div class="line">* 定义和使用新的嵌套类型</div><div class="line">* 使一个已有类型符合某个协议</div><div class="line"></div><div class="line">**扩展协议**</div></pre></td></tr></table></figure></p>
<p>extension SomeType: SomeProtocol, AnotherProctocol {<br>    // 协议实现写到这里<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**计算型属性**</div></pre></td></tr></table></figure></p>
<p>extension Int {<br>   var add: Int {return self + 100 }<br>}<br>let addition = 3.add<br>print(“加法运算后的值：(addition)”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**构造器**</div><div class="line"></div><div class="line">扩展可以向类中添加新的便利构造器init(),但是他们不能像类中添加新的指定构造器或析构函数deinit().</div><div class="line"></div><div class="line">**可变实例方法**</div></pre></td></tr></table></figure></p>
<p>extension Double {<br>   mutating func square() {<br>      let pi = 3.1415<br>      self = pi <em> self </em> self<br>   }<br>}</p>
<p>var Trial1 = 3.3<br>Trial1.square()<br>print(“圆的面积为: (Trial1)”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**下标**</div></pre></td></tr></table></figure></p>
<p>extension Int {<br>   subscript(var multtable: Int) -&gt; Int {<br>      var no1 = 1<br>      while multtable &gt; 0 {<br>         no1 *= 10<br>         –multtable<br>      }<br>      return (self / no1) % 10<br>   }<br>}</p>
<p>print(12[0])<br>print(7869[1])</p>
<p>输出:<br>2<br>6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;span id=&quot;协议&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">协议</div><div class="line">==============</div><div class="line"></div><div class="line">如果类在遵循协议的同时拥有父类，应该将父类名放在协议名之前，以逗号分隔。</div></pre></td></tr></table></figure></p>
<p>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {<br>    // 类的内容<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**对属性的规定**</div><div class="line"></div><div class="line">协议用于指定特定的实例属性或类属性,而不用指定是存储属性或计算属性.此外还必须指明是只读的还是刻毒可写的.</div><div class="line"></div><div class="line">协议中的通常用var来声明变量属性,在类型声明后加上&#123;set get&#125;来表示属性是可读可写的,只读属性则用&#123;get&#125;来表示.</div></pre></td></tr></table></figure></p>
<p>protocol classa {</p>
<pre><code>var marks: Int { get set }
var result: Bool { get }

func attendance() -&gt; String
func markssecured() -&gt; String
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**对 Mutating方法的规定**</div><div class="line"></div><div class="line">有时候需要在方法中改变它的实例.</div><div class="line"></div><div class="line">例如: 值类型(结构体,枚举)的实例方法中,将mutating作为函数的前缀,写在func之前,表示可以在该方法中修改它所属的实例及其实例属性的值.</div></pre></td></tr></table></figure></p>
<p>protocol daysofaweek {<br>    mutating func show()<br>}</p>
<p>enum days: daysofaweek {<br>    case sun, mon, tue, wed, thurs, fri, sat<br>    mutating func show() {<br>        switch self {<br>        case .sun:<br>            self = .sun<br>            print(“Sunday”)<br>        case .mon:<br>            self = .mon<br>            print(“Monday”)<br>        case .tue:<br>            self = .tue<br>            print(“Tuesday”)<br>        case .wed:<br>            self = .wed<br>            print(“Wednesday”)<br>        case .thurs:<br>            self = .thurs<br>            print(“Wednesday”)<br>        case .fri:<br>            self = .fri<br>            print(“Wednesday”)<br>        case .sat:<br>            self = .sat<br>            print(“Saturday”)<br>        default:<br>            print(“NO Such Day”)<br>        }<br>    }<br>}</p>
<p>var res = days.wed<br>res.show()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**对构造器的规定**</div><div class="line"></div><div class="line">协议可以要求他的遵循者实现指定的构造器.</div></pre></td></tr></table></figure></p>
<p>protocol tcpprotocol {<br>   init(aprot: Int)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**协议类型** : 可以作为参数,返回值,常量,变量,属性,容器的属性</div><div class="line"></div><div class="line">**makeIterator(),map**</div></pre></td></tr></table></figure></p>
<p>protocol Generator {<br>    associatedtype members<br>    func next() -&gt; members?<br>}</p>
<p>var items = [10,20,30].makeIterator()<br>while let x = items.next() {<br>    print(x)<br>}</p>
<p>for lists in [1,2,3].map( {i in i*5}) {<br>    print(lists)<br>}</p>
<p>print([100,200,300])<br>print([1,2,3].map({i in i*10}))</p>
<p>输出:<br>10<br>20<br>30<br>5<br>10<br>15<br>[100, 200, 300]<br>[10, 20, 30]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以在扩展中添加协议</div><div class="line"></div><div class="line">**协议的继承**</div><div class="line"></div><div class="line">协议能够继承一个或多个其他协议,可以在继承的协议继承上增加新的内容要求.</div><div class="line"></div><div class="line">协议的继承语法与类的继承想死,多个被继承的协议间用都好分隔:</div></pre></td></tr></table></figure></p>
<p>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {<br>    // 协议定义<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**类专属协议:**</div><div class="line"></div><div class="line">可以在协议的继承列表中,通过天剑class关键字,限制协议只能适配到类(class)类型.</div><div class="line"></div><div class="line">该class关键字必须是第一个出现在协议的继承列表中,其后,才是其他继承协议,</div></pre></td></tr></table></figure></p>
<p>protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {<br>    // 协议定义<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**协议合成**</div><div class="line"></div><div class="line">swift支持合成多个协议,这在我们需要同时遵守多个协议是非常有用</div></pre></td></tr></table></figure></p>
<p>protocol Stname {<br>    var name: String { get }<br>}</p>
<p>protocol Stage {<br>    var age: Int { get }<br>}</p>
<p>struct Person: Stname, Stage {<br>    var name: String<br>    var age: Int<br>}</p>
<p>func show(celebrator: Stname &amp; Stage) {<br>    print(“(celebrator.name) is (celebrator.age) years old”)<br>}</p>
<p>let studname = Person(name: “Priya”, age: 21)<br>print(studname)</p>
<p>let stud = Person(name: “Rehan”, age: 29)<br>print(stud)</p>
<p>let student = Person(name: “Roshan”, age: 19)<br>print(student)</p>
<p>输出:<br>Person(name: “Priya”, age: 21)<br>Person(name: “Rehan”, age: 29)<br>Person(name: “Roshan”, age: 19)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**检验协议的一致性**</div><div class="line"></div><div class="line">可以使用is和as操作符来检查是否遵循某一协议或强制转化为某已类型.</div><div class="line"></div><div class="line">* is操作符用来检查视力是否遵循了某个协议</div><div class="line">* as?返回一个可选值,当视力遵循协议时,返回该协议类型;否则返回nil</div><div class="line">* as用以强制向下转型,如果强转失败,会引起运行时错误.</div></pre></td></tr></table></figure></p>
<p>protocol HasArea {<br>    var area: Double { get }<br>}</p>
<p>// 定义了Circle类，都遵循了HasArea协议<br>class Circle: HasArea {<br>    let pi = 3.1415927<br>    var radius: Double<br>    var area: Double { return pi <em> radius </em> radius }<br>    init(radius: Double) { self.radius = radius }<br>}</p>
<p>// 定义了Country类，都遵循了HasArea协议<br>class Country: HasArea {<br>    var area: Double<br>    init(area: Double) { self.area = area }<br>}</p>
<p>// Animal是一个没有实现HasArea协议的类<br>class Animal {<br>    var legs: Int<br>    init(legs: Int) { self.legs = legs }<br>}</p>
<p>let objects: [AnyObject] = [<br>    Circle(radius: 2.0),<br>    Country(area: 243_610),<br>    Animal(legs: 4)<br>]</p>
<p>for object in objects {<br>    // 对迭代出的每一个元素进行检查，看它是否遵循了HasArea协议<br>    if let objectWithArea = object as? HasArea {<br>        print(“面积为 (objectWithArea.area)”)<br>    } else {<br>        print(“没有面积”)<br>    }<br>}</p>
<p>输出:<br>面积为 12.5663708<br>面积为 243610.0<br>没有面积<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;span id=&quot;泛型&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">swift 泛型</div><div class="line">==============</div></pre></td></tr></table></figure></p>
<p>// 定义一个交换两个变量的函数<br>func swapTwoValues<t>(<em> a: inout T, </em> b: inout T) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}</t></p>
<p>var numb1 = 100<br>var numb2 = 200</p>
<p>print(“交换前数据:  (numb1) 和 (numb2)”)<br>swapTwoValues(&amp;numb1, &amp;numb2)<br>print(“交换后数据: (numb1) 和 (numb2)”)</p>
<p>var str1 = “A”<br>var str2 = “B”</p>
<p>print(“交换前数据:  (str1) 和 (str2)”)<br>swapTwoValues(&amp;str1, &amp;str2)<br>print(“交换后数据: (str1) 和 (str2)”)</p>
<p>输出:<br>交换前数据:  100 和 200<br>交换后数据: 200 和 100<br>交换前数据:  A 和 B<br>交换后数据: B 和 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">泛型使用了占位类型名(在这里用字母T来表示)来代替视力类型名(例如Int,String或Double)</div><div class="line"></div><div class="line">swapTwoValues后面跟着占位类型名(T),并用尖括号括起来(&lt;T&gt;).这个尖括号告诉swift那个T是swapTwoValues(_:_:)函数定义内的一个占位类型名,因此swift不会去查找名为T的实际类型.</div><div class="line"></div><div class="line">**泛型类型**</div></pre></td></tr></table></figure></p>
<p>struct Stack<element> {<br>    var items = <a href="">Element</a><br>    mutating func push(_ item: Element) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Element {<br>        return items.removeLast()<br>    }<br>}</element></p>
<p>var stackOfStrings = Stack<string>()<br>print(“字符串元素入栈: “)<br>stackOfStrings.push(“google”)<br>stackOfStrings.push(“runoob”)<br>print(stackOfStrings.items);</string></p>
<p>let deletetos = stackOfStrings.pop()<br>print(“出栈元素: “ + deletetos)</p>
<p>var stackOfInts = Stack<int>()<br>print(“整数元素入栈: “)<br>stackOfInts.push(1)<br>stackOfInts.push(2)<br>print(stackOfInts.items);</int></p>
<p>输出:<br>字符串元素入栈:<br>[“google”, “runoob”]<br>出栈元素: runoob<br>整数元素入栈:<br>[1, 2]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这些方法被标记为mutating,因为他们需要修改结构体的items数组.</div><div class="line"></div><div class="line">**扩展泛型类型**</div></pre></td></tr></table></figure></p>
<p>extension Stack {<br>    var topItem: Element? {<br>       return items.isEmpty ? nil : items[items.count - 1]<br>    }<br>}<br>if let topItem = stackOfStrings.topItem {<br>    print(“栈中的顶部元素是：(topItem).”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们也可以通过扩展一个存在的类型来指定关联类型.</div><div class="line"></div><div class="line">例如swift的Array类型已经提供append(_:)方法,一个count属性,以及一个接受Int类型索引的下标用以检索其元素.这三个功能都符合Container协议的要求,所以你只需简单地声明Array采纳该协议就可以扩展Array.以下实例创建一个空扩展即可:</div><div class="line">`extension Array:Container()`</div><div class="line"></div><div class="line"></div><div class="line">**类型约束**</div><div class="line"></div><div class="line">类型约束指定了一个必须继承自指定类的类型参数,或者遵循一个特定的协议或协议构成.</div></pre></td></tr></table></figure></p>
<p>func someFunction<t: someclass,="" u:="" someprotocol="">(someT: T, someU: U) {<br>    // 这里是泛型函数的函数体部分<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面这个函数有两个类型参数.第一个类型参数T,有一个要求T必须是SomeClass子类的类型约束,第二个类型参数U,有一个要求U必须符合SomeProtocol协议的类型约束.</div><div class="line"></div><div class="line">实例</div></pre></td></tr></table></figure></t:></p>
<p>// 非泛型函数，查找指定字符串在数组中的索引<br>func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {<br>    for (index, value) in array.enumerated() {<br>        if value == valueToFind {<br>            // 找到返回索引值<br>            return index<br>        }<br>    }<br>    return nil<br>}</p>
<p>let strings = [“google”, “weibo”, “taobao”, “runoob”, “facebook”]<br>if let foundIndex = findIndex(ofString: “runoob”, in: strings) {<br>    print(“runoob 的索引为 (foundIndex)”)<br>}</p>
<p>输出:<br>runoob 的索引为 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**关联类**</div><div class="line"></div><div class="line">swift中使用associatedtype关键字来设置关联类型实例.</div><div class="line"></div><div class="line">下面例子定义了一个Cont协议,改协议定义了一个关联类型ItemType.</div><div class="line"></div><div class="line">Container协议只指定了三个任何遵从Container协议的类型必须提供的功能.遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能.</div></pre></td></tr></table></figure></p>
<p>// Container 协议<br>protocol Container {<br>    associatedtype ItemType<br>    // 添加一个新元素到容器里<br>    mutating func append(_ item: ItemType)<br>    // 获取容器中元素的数<br>    var count: Int { get }<br>    // 通过索引值类型为 Int 的下标检索到容器中的每一个元素<br>    subscript(i: Int) -&gt; ItemType { get }<br>}</p>
<p>// Stack 结构体遵从 Container 协议<br>struct Stack<element>: Container {<br>    // Stack<element> 的原始实现部分<br>    var items = <a href="">Element</a><br>    mutating func push(<em> item: Element) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Element {<br>        return items.removeLast()<br>    }<br>    // Container 协议的实现部分<br>    mutating func append(</em> item: Element) {<br>        self.push(item)<br>    }<br>    var count: Int {<br>        return items.count<br>    }<br>    subscript(i: Int) -&gt; Element {<br>        return items[i]<br>    }<br>}</element></element></p>
<p>var tos = Stack<string>()<br>tos.push(“google”)<br>tos.push(“runoob”)<br>tos.push(“taobao”)<br>// 元素列表<br>print(tos.items)<br>// 元素个数<br>print( tos.count)</string></p>
<p>输出:<br>[“google”, “runoob”, “taobao”]<br>3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**Where语句**</div><div class="line"></div><div class="line">类型约束能够确保类型符合泛型函数或类的定义约束.</div><div class="line"></div><div class="line">可以在参数列表中通过where语句定义参数的约束.</div></pre></td></tr></table></figure></p>
<p>// 扩展，将 Array 当作 Container 来使用<br>extension Array: Container {}</p>
<p>func allItemsMatch<c1: container,="" c2:="" container=""><br>    (<em> someContainer: C1, </em> anotherContainer: C2) -&gt; Bool<br>    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {</c1:></p>
<pre><code>// 检查两个容器含有相同数量的元素
if someContainer.count != anotherContainer.count {
    return false
}

// 检查每一对元素是否相等
for i in 0..&lt;someContainer.count {
    if someContainer[i] != anotherContainer[i] {
        return false
    }
}

// 所有元素都匹配，返回 true
return true
</code></pre><p>}<br>var tos = Stack<string>()<br>tos.push(“google”)<br>tos.push(“runoob”)<br>tos.push(“taobao”)</string></p>
<p>var aos = [“google”, “runoob”, “taobao”]</p>
<p>if allItemsMatch(tos, aos) {<br>    print(“匹配所有元素”)<br>} else {<br>    print(“元素不匹配”)<br>}</p>
<p>输出:<br>匹配所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;span id=&quot;访问控制&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">访问控制</div><div class="line">==============</div><div class="line"></div><div class="line">访问控制基于模块与源文件.</div><div class="line"></div><div class="line">模块指的是以独立单元构建和发布的Framework或Application.在swift中的一个模块可以使用import关键字引入另外一个模块.</div><div class="line"></div><div class="line">源文件是单个源码文件,它通常属于一个模块,源文件可以包含多个类和函数的定义.</div><div class="line"></div><div class="line">访问级别     |  定义</div><div class="line">----------  |--------------</div><div class="line">public		  | 可以访问自己模块中源文件里的任何实体,别人也可以通过引入该模块来访问源文件里的所有实体.</div><div class="line">internal    | 可以访问自己模块中源文件里的任何实体,但是别人不能访问该模块中源文件里的实体.</div><div class="line">fileprivate | 文件内私有,只能在当前源文件中使用</div><div class="line">private     | 只能在类中访问,离开了这个类或者结构体的作用域外面就无法访问.</div><div class="line"></div><div class="line">public是最高级访问级别,private为最低级访问级别.</div></pre></td></tr></table></figure></p>
<p>public class SomePublicClass {}<br>internal class SomeInternalClass {}<br>fileprivate class SomeFilePrivateClass {}<br>private class SomePrivateClass {}</p>
<p>public var somePublicVariable = 0<br>internal let someInternalConstant = 0<br>fileprivate func someFilePrivateFunction() {}<br>private func somePrivateFunction() {}<br>```</p>
<p>除非有特殊的说明,否则实体都使用默认的访问别internal.</p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/12/30/git-command/" data-toggle="tooltip" data-placement="top" title="git常用命令">&larr; Previous Post</a>
                        </li>
                    
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/longpengfei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/LongPF">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/longpengfei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/LongPF">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; longpengfei&#39;s blog 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("longpengfei.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="longpengfei.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
