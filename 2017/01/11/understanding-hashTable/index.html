<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="null">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          了解哈希表 - 龙鹏飞的博客 | longpengfei&#39;s Blog
        
    </title>

    <link rel="canonical" href="longpengfei.com/2017/01/11/understanding-hashTable/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">longpengfei&#39;s blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="longpengfei.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#哈希表" title="哈希表">哈希表</a>
                        
                    </div>
                    <h1>了解哈希表</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by longpengfei on
                        2017-01-11
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>散列表(哈希表),是根据键而直接访问在内存存储位置的数据结构.也就是说,他通过计算一个关于键值的函数,将所需查询的数据映射到表中一个位置来访问记录,这加快了查找速度,这个映射函数称作散列函数,存放的数组称作散列表.</p>
<p>一个通俗的例子是,通讯录,通过字母w来查找’王’,这里用人名作关键字.</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>若关键字为k,则其值存放在f(k)的存储位置上.由此,不需要比较便可直接取得所查记录.f为散列函数,按这个思想简历的表为散列表.</p>
</li>
<li><p>对不同搞得关键字可能得到同一散列地址,即k1!=k2,f(k1)=f(k2),这种现象叫冲突,k1,k2称为同义词.综上所述根据散列函数f和处理冲突的方法将一组关键字映射到一个有限的连续的地址集(区间)上,并以关键字在地址集中的’像’作为记录在表中的存储位置,这种表便称为<strong>散列表</strong>,这一映射过程称为<strong>散列造表</strong>或散列,所得的存储位置称<strong>散列地址</strong>.</p>
</li>
<li><p>若对于关键字集合中的任一个关键字,经散列函数映像到地址结合中任何一个地址的概率是相等的,则称此类散列函数为<strong>均匀散列函数</strong>,这就是使关键字经过散列函数得到一个’随机的地址’,从而减少冲突.</p>
</li>
</ul>
<h1 id="构造散列函数"><a href="#构造散列函数" class="headerlink" title="构造散列函数"></a>构造散列函数</h1><p>散列函数能使一个数据序列的访问过程更加迅速有效,通过散列函数,数据元素将被更快定位.</p>
<ul>
<li><strong>1. 直接定址法 :</strong> 取关键字或关键字的某个线性函数值为散列地址.即hash(k)=a*k+b,其中ab为常数.这种散列函数叫做自身函数.</li>
<li><strong>2. 数字分析法 :</strong> 假设关键字是以r为基的数,并且哈希表中可能出现的关键字都是事先知道的,则可取关键字的若干数位组成哈希地址.</li>
<li><strong>3. 平方取中法 :</strong> 取关键字平方后的中间几位为哈希地址.一个数平方后的中间几位数和数的每一位都相关,由此使随机分布的关键字得到的哈希地址也是随机的.取得位数由表长决定</li>
<li><strong>4. 折叠法 :</strong> 将关键字分割成位数相同的几部分(最后一部分的位数可以不同),然后取这几部分的叠加和(舍去进位)最为哈希地址</li>
<li><strong>5. 随机数法</strong> </li>
<li><strong>6. 除留余数法 :</strong>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即hash(k)=k mod p, p&lt;=m.不仅可以对关键字直接取模,也可以在<strong>折叠法</strong>,平方取中法等运算之后取模.对p的选择很重要,一般取素数或m,若p选择不好,容易产生冲突</li>
</ul>
<h1 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h1><p>为了知道冲突产生的相同散列函数地址所对应的关键字,必须选用另外的散列函数,或者对冲突结果进行处理.而不发生冲突的可能性是非常之小的,所以通常对冲突进行处理.</p>
<ul>
<li><font color="#CD5C5C"><strong>开放定址法</strong></font>(open addressing) : hash<sub>i</sub> = (hash(key) + d<sub>i</sub>) mod m  ,其中hash(key)为散列函数,m为散列表长,d<sub>i</sub>为增量序列,i为已发生冲突次数.增量序列可有下列取法:</li>
</ul>
<p>d<sub>i</sub> = 1,2,3…(m-1)称为线性探测;即 d<sub>i</sub> = i,或者为其他线性函数.相当于诸葛探测粗放地址的表,知道查到一个空单元,把散列地址存放在该空单元.</p>
<p>d<sub>i</sub> = &plusmn;1&sup2;,&plusmn;2&sup2;,&plusmn;3&sup2;…&plusmn;k&sup2;,(k&le;m/2),称为平方探测,相对线性探测,相对于发生冲突时探测间隔d<sub>i</sub> = i&sup2;个单元的位置是否为空,如果为空,降低至存放进去</p>
<p>d<sub>i</sub> = 伪随机数,称为 伪随机探测</p>
<p>显示线性探测填装一个散列表的过程 : </p>
<p>关键字为 {89, 18, 49, 58, 69} 插入到一个散列表中的情况.此时线性探测的方法是取 d<sub>i</sub> = i .并嘉定取关键字除以10的余数为散列函数法则.</p>
<table>
<thead>
<tr>
<th>散列地址</th>
<th>空表</th>
<th>插入89</th>
<th>插入18</th>
<th>插入49</th>
<th>插入58</th>
<th>插入69</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>49</td>
<td>49</td>
<td>49</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>58</td>
<td>58</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>69</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
<td>18</td>
<td>18</td>
<td>18</td>
<td>18</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>89</td>
<td>89</td>
<td>89</td>
<td>89</td>
<td>89</td>
</tr>
</tbody>
</table>
<p>第一次冲突发生在填装发生在填装49的时候.地址为9的单元已经填装了89这个关键字,所以取 i = 1, 往下查找一个单位,发现为空,说以将49填装在地址为0的空单元.第二次的冲突则发生在58上,取 i = 2,往下查找两个单位,将58填装在地址为1的空单元. 69同理.</p>
<p>表的大小玄子至关重要,此处取10作为大小,发生冲突的几率比选择质数11作为到校的可能性大.越是质数,mod取余就月可能均匀分布在表的各处.</p>
<p><strong>聚集</strong>散列函数的结果不均匀地占据表的单元.散列到区块中的任何关键字需要查找多次试选单元才能插入表中,解决冲突,造成时间浪费.对于开放定址法,聚集会造成性能的灾难性损失,是必须避免的.</p>
<font color="#CD5C5C"><strong>单独链表法 :</strong></font> 将散列到同一个储存位置的所有元素保存在一个链表中.实现时,一种策略是散列表同一位置的所有冲突结果都是用栈存放的,新元素被插入到表的前端还是后段完全取决于怎么方便.<br><br><font color="#CD5C5C"><strong>双散列 .</strong></font>

<font color="#CD5C5C"><strong>再散列 :</strong></font> hash<sub>i</sub> = hash<sub>i</sub>(key) , i = 1,2,..k. hash<sub>i</sub>是一些散列函数.即在上次散列计算冲突时,利用该次冲突的散列函数地址产生新的散列函数地址,直到冲突不在发生.这种方法不易产生 聚集 ,但增加了计算时间.<br><br><font color="#CD5C5C"><strong>建立一个公共溢出区 :</strong></font> 这种方法的基本思想是: 将哈希表分为基本表和溢出表两部分, 凡是和基本表发生冲突的元素,一律填入溢出表.<br><br><font color="#cd5c5c"><strong>拉链法和开放定址法比较 :</strong></font>

<p><strong>拉链法的优点 :</strong></p>
<ul>
<li><ol>
<li>拉链法处理冲突简单,且无堆积现象,即非同义词绝不会发生冲突,因此平均查找长度较短;</li>
</ol>
</li>
<li><ol>
<li>由于拉链法中各链表上的结点空间是动态申请的,故它更适合于造表前无法确定表长的情况.</li>
</ol>
</li>
<li><ol>
<li>开放定址法为减少冲突,要求填充因子&alpha;较小,故当结点规模较大时会浪费很多空间.而拉链法中可取&alpha;&ge;1且结点较大时,拉链发中增加的指针域可忽略不计,一次节省空间.</li>
</ol>
</li>
<li><ol>
<li>在用拉链法构造的散列表中,删除结点的操作易于实现.只要简单地删去链表上相对应的结点即可.</li>
</ol>
</li>
</ul>
<p><strong>拉链法的去电 :</strong></p>
<p>指针需要额外的空间,故当结点规模较小时,开放定址法较为节省空间,而若节省的指针空间用来扩大散列表的规模,可使装填椅子变小,这又减少了开放定址法中的冲突,从而提高平均查找速度.</p>
<h1 id="C语言实现实现"><a href="#C语言实现实现" class="headerlink" title="C语言实现实现 "></a>C语言实现实现 </h1><ul>
<li>开放定址法 :</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">初始化 </div><div class="line"></div><div class="line">HashTable (int TableSize)</div><div class="line">&#123;</div><div class="line">	HashTable H;</div><div class="line">	int i;</div><div class="line">	/* 为散列分配空间 */</div><div class="line">	H = malloc( sizeof( struct HashTable ) );</div><div class="line">	</div><div class="line">	/* 散列表大小为一个质数 */</div><div class="line">	H-&gt;TableSize = Prime;</div><div class="line">	</div><div class="line">	/* 分配表所有地址的空间. */</div><div class="line">	H-&gt;Cells = malloc( sizeof( cell ) * H-&gt;TableSize );</div><div class="line">	</div><div class="line">	/*  地址初始为空 */</div><div class="line">	for ( i = 0; i &lt; H-&gt;TableSize; i++ )</div><div class="line">		 H-&gt;Cells[i].info = Empty;</div><div class="line">	</div><div class="line">	return H;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">查找空单元并插入</div><div class="line"></div><div class="line">Position Find ( ElementType Key, HashTable H )</div><div class="line">&#123;</div><div class="line">	Position Current;</div><div class="line">	int CollisionNum;</div><div class="line">	</div><div class="line">	/* 冲突次数初始为0 */</div><div class="line">	/* 通过表的大小对关键字进行处理. */</div><div class="line">	CollisionNum = 0;</div><div class="line">	Current = Hash( Key, H-&gt;TableSize );</div><div class="line">	</div><div class="line">	/* 不为空时进行查找 */</div><div class="line">	while( H-&gt;Cells[Current].info != Empty &amp;&amp; H-&gt;Cells[Current].Element != Key )</div><div class="line">	&#123;</div><div class="line">		Current = ++CollisionNum * ++CollisionNum;</div><div class="line">		</div><div class="line">		/* 向下查找超过范围时回到表开头 */</div><div class="line">		if (Current &gt;= H-&gt;TableSize)</div><div class="line">			Current -= H-&gt;TableSize;</div><div class="line">	&#125;</div><div class="line">	return Current;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h1><p>散列表的查找过程基本上和造表过程相同.一些关键码可通过散列函数转换的地址直接找到,另一些关键码在散列函数得到的地址上产生了冲突,需要按处理冲突的方法进行查找.在介绍三种处理冲突的方法中,产生冲突后的查找任然是给定值与关键码进行比较过程.所以,对散列表查找效率的量度,依然用平均查找长度来衡量.</p>
<p>查找过程中,关键码的比较次数,取决于产生冲突的多少,产生的冲突少,查找效率就高,产生的冲突多,查找效率就低.因此,印象产生冲突多少的因素,就是影响查找效率的因素.影响产生冲突度多少有一下三个因素 :</p>
<ol>
<li>散列函数是否均匀;</li>
<li>处理冲突的方法;</li>
<li>散列表的载荷因子.</li>
</ol>
<h1 id="载荷因子"><a href="#载荷因子" class="headerlink" title="载荷因子"></a>载荷因子</h1><p>散列表的载荷因子定义为 : &alpha; = 填入表中的元素个数 / 散列表的长度</p>
<p>&alpha;越大产生冲突的可能性就越大.散列表的平均查找长度是载荷因子&alpha;的函数,只是不同处理冲突的方法又不同的函数.</p>
<p>对于卡房定址法,载荷因子是特别重要要素,应严格限制在0.7-0.8一下.超过0.8,查表的cpu缓存不命中按指数曲线上升.因此,一些采用开放定址法的hash库,如java的系统限制了载荷因子为0.75,超过此值将resize散列表.</p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2017/01/12/uikit-performance-optimization/" data-toggle="tooltip" data-placement="top" title="UIKit性能优化">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2017/01/10/ios-interview-questions/" data-toggle="tooltip" data-placement="top" title="">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/longpengfei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/LongPF">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/longpengfei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/LongPF">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; longpengfei&#39;s blog 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("longpengfei.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="longpengfei.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
